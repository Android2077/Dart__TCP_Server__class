import 'dart:io';
import 'dart:convert';
import 'dart:typed_data';    //для "Uint8List"


import 'TCP_Server__class.dart';


void main() async
{

  //--------------------------------------------------------TCP_Server__class:Begin-----------------------------------------------------------------------

  //Это простой класс обертка над серверным TCP-сокетом.

  //Доступные методы:
  //- set__Shared_Callback_for_SocketRead         - устанавливает обший для всех Сокетов и Аццепторов Колбек, который будет вызыватся при чтении Входяших данных из Сокета.
  //- set__Shared_Callback_for_Connect            - устанавливает обший для всех Сокетов и Аццепторов Колбек, который будет вызыватся при изменеии состояния Соединения.
  //- set__Shared_Callback_for_CloseSocket        - устанавливает обший для всех Сокетов и Аццепторов Колбек, который будет вызыватся при закрытии Сокета.
  //- set__Shared_Callback_for_CloseAcceptor      - устанавливает обший для всех Аццепторов Колбек, который будет вызыватся при закрытии Аццептора.

  //- add__NewAcceptor                            - доавбляет новую структуру Аццептора[прослушивателя].
  //- get__Acceptor_by_Name                       - возвращает стурктуру Аццептора по его имени указанном при "add__NewAcceptor"
  //- destroy_All_acceptor                        - уничтожает все Аццепторы.

  //Методы Ацептора:
  //- start_acceptor                              - запускает Аццептор на прослушивание.
  //- destroy_acceptor                            - уничтожает Аццептор.
  //- get__Socket_List_Size                       - возвращает кол-во Сокетов на Аццепторе.
  //- close_Socket                                - закрывает Сокет на Аццепторе.
  //- close_AllSocket                             - закрывает все Сокеты на Аццепторе.
  //- destroy_Socket                              - уничтожает Сокет на Аццепторе.
  //- destroy_AllSocket                           - уничтожает все СОкеты на Аццепторе.
  //- set__ReadParamFlag_for_Socket               - устанавливает режим чтения данных из Сокета на Аццепторе.
  //- set__ReadUntill_Seperator_for_Socket        - устанавливает "разделитель" для режима чтения "ReadUntill"
  //- set__AccumulateBuffer_Size_for_Socket       - устанавливает размер буффера для режима чтения "AccumulateBuffer"
  //- send__Bytes_to_socket                       - отправляет данные в Сокет.


  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------
  void Function(TCP_Server__class TCP_Server__ref, Acceptor_struct? Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, String text_error) lambda_error_ = (TCP_Server__class TCP_Server__ref, Acceptor_struct? Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, String text_error) async
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов, как будут перехватыываться исключения/ошибки.
    //TCP_Server__ref        - ссылка на сам обьект класса.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.
    //Socket_Struct__ref     - ссылка на структуру сокета указанного Аццептора.
    //text_error             - текст ошибки.



    if(Acceptor_struct__ref != null)
    {
      print("${Acceptor_struct__ref.Acceptor_Name} : ${text_error}");
    }
    else
    {
      print('Error_exeption: ${text_error}');
    }

  };


  TCP_Server__class TCP_Server_ = new TCP_Server__class(lambda_error_);   //Создаем обьект класса.
  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------



  //--------------------------------------------------------1:set__Shared_Callback_for_SocketRead:Begin-------------------------------------------------------------------
  //Устанавливает общий колбек для всех Используемых Сокетов и Аццепторов. Данный колбек будет вызыватся каждый раз, как будут приходить Входящие данные на Сокет.
  //Установка данного колбека не является обязательным.

  void  Function(TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, Uint8List Incoming_data) User_Shared_lambda_for_Read_ = (TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, Uint8List Incoming_data)async
  {
    //TCP_Server__class__ref - ссылка на сам обьект класса "TCP_Server__class", который вызовал данный колбек.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.
    //Socket_Struct__ref     - ссылка на структуру Сокета.
    //Incoming_data          - Буфер "Uint8List" с пришедшими Входящими данными доступными для чтения в данный момент. После завершения колбека ссылка на днные "Incoming_data" - становтся невалдиными, обращатся к ним уже Нельзя! Поэтому если нужно их сохранить - данные необхоимо ПЕРЕКОПИРОВАТЬ в свой буффер.

    print("${Acceptor_struct__ref.Acceptor_Name} : data_bytes_size: ${Incoming_data.length} : ${Incoming_data}");
    print('${Acceptor_struct__ref.Acceptor_Name} : data_bytes_size: ${Incoming_data.length} : ${utf8.decode(Incoming_data)}');   //Преобразуем данные из буффера в Dart`овский String(UTF-16), но при это нужно гарантированно знать, что в "data" находится валидная UTF-8 кодировка, иначе ошибка в рантайме.


    //Acceptor_struct__ref.send__Bytes_to_socket(Socket_Struct__ref!, Uint8List.fromList(utf8.encode("ECHO_Hello1_,_ECHO_Hello2_,_END")), true);
    //Acceptor_struct__ref.close_Socket(Socket_Struct__ref, false, true);
  };


  TCP_Server_.set__Shared_Callback_for_SocketRead(User_Shared_lambda_for_Read_);
  //--------------------------------------------------------2:set__Shared_Callback_for_SocketRead:End-------------------------------------------------------------------


  //--------------------------------------------------------3:set__Shared_Callback_for_Connect:Begin-------------------------------------------------------------------
  //Устанавливает общий колбек для всех Используемых Сокетов и Аццепторов. Данные колбек будет вызывается каждый раз, как будет устанавливатся или разрыватся Соединение на каком либо из используемых Сокетов на конкретном Аццепторе.
  //Установка данного колбека не является обязательным.

  void Function(TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, bool Connection_flag) lambda_for_ConnectionStatus = (TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, bool Connection_flag)
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов для всех добавленных Аццепторов, при изменении статуса уствноки соединения для Сокета.
    //TCP_Server__class__ref - ссылка на сам обьект класса "TCP_Server__class", который вызовал данный колбек.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.
    //Socket_Struct__ref     - ссылка на структуру сокета.
    //Connection_flag        - логический флаг соединения на Сокете "Socket_Struct__ref".

    if(Connection_flag == true)
    {
      print('${Acceptor_struct__ref.Acceptor_Name} :Connect new Socket');
    }
    else
    {
      print('${Acceptor_struct__ref.Acceptor_Name} :Socket Disconect');
    }

  };

  TCP_Server_.set__Shared_Callback_for_Connect(lambda_for_ConnectionStatus);

  //--------------------------------------------------------3:set__Shared_Callback_for_Connect:End-------------------------------------------------------------------


  //--------------------------------------------------------4:set__Shared_Callback_for_CloseSocket:Begin-------------------------------------------------------------------
  //Устанавливает общий колбек для всех Используемых Сокетов и Аццепторов. Данные колбек будет вызывается каждый раз, как будет закрыватся Сокет на каком либо из используемых Ацепторов.
  //Установка данного колбека не является обязательным.

  Function(TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct Socket_Struct_ref) User_lambda_for_CloseSocket_ = (TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct Socket_Struct_ref)
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов, в случае, если Сокет по какой либо причине закрывается.
    //TCP_Server__class__ref - ссылка на сам обьект класса "TCP_Server__class", который вызовал данный колбек.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.
    //Socket_Struct__ref     - ссылка на структуру сокета.

    print("Close_Socket:${Acceptor_struct__ref.Acceptor_Name}");
  };

  TCP_Server_.set__Shared_Callback_for_CloseSocket(User_lambda_for_CloseSocket_);
  //--------------------------------------------------------4:set__Shared_Callback_for_CloseSocket:End-------------------------------------------------------------------


  //--------------------------------------------------------5:set__Shared_Callback_for_CloseAcceptor:Begin-------------------------------------------------------------------
  //Устанавливает общий колбек для всех Используемых  Аццепторов. Данные колбек будет вызывается каждый раз, как будет закрыватся ранее добавленный Аццептор.
  //Установка данного колбека не является обязательным.

  Function(TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref) User_lambda_for_CloseAcceptor_ = (TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref)
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов, в случае, если Сокет по какой либо причине закрывается.
    //TCP_Server__class__ref - ссылка на сам обьект класса "TCP_Server__class", который вызовал данный колбек.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.

    print("Close_Acceptor:${Acceptor_struct__ref.Acceptor_Name}");
  };

  TCP_Server_.set__Shared_Callback_for_CloseAcceptor(User_lambda_for_CloseAcceptor_);
  //--------------------------------------------------------5:set__Shared_Callback_for_CloseAcceptor:End-------------------------------------------------------------------



  //--------------------------------------------------------6:add__NewAcceptor:Begin-------------------------------------------------------------------
  //Данный метод создает и добавляет новый Аццептор. Аццептор - это обьект, который принимает на указанном порту Входящие соединения с удаленным IP - создавая на каждое такое соединение новый сокет или используя ранее созданный сокет, но уже закртый.

  //-------------------------------------------------
  String Acceptor_Name_1    =  "Acceptor_Name_1";                          //Идентификатор Аццептора. НЕ ДОЛЖЕН ПОВТОРЯЮТСЯ С ДРУГИМИ ДОБАВЛЕННЫМИ АЦЦЕТОПРАМИ.
  InternetAddress IP_type_1 = InternetAddress.anyIPv4;                     //Тип протокола TCP: anyIPv4 - принимает соединение по IPv4 протоколу, как из вне, так и локально; anyIPv6 -  - принимает соединение по IPv6 протоколу, как из вне, так и локально; loopbackIPv4 - принимает соединение по IPv4 протоколу только из локальной сети; loopbackIPv6 - принимает соединение по IPv6 протоколу только из локальной сети.
  int num_port_1            = 1234;                                                 //Порт который прослушивает Аццетор и принимает соединения.
  //-------------------------------------------------


  Acceptor_struct Acceptor_struct__ref = await TCP_Server_.add__NewAcceptor(Acceptor_Name_1, IP_type_1, num_port_1);
  //--------------------------------------------------------6:add__NewAcceptor:End-------------------------------------------------------------------



  //--------------------------------------------------------7:get__Acceptor_by_Name:Begin-------------------------------------------------------------------

  //Возвращает ссылку обьект "Acceptor_struct" по указанному имени Аццептора, который использовался ранее при добавлении при вызвове "add__NewAcceptor".

  Acceptor_struct? Acceptor_struct__ref_1 = TCP_Server_.get__Acceptor_by_Name(Acceptor_Name_1);

  if(Acceptor_struct__ref_1 == null)
  {
    print("${Acceptor_Name_1} - not found");

    return;
  }
  //--------------------------------------------------------7:get__Acceptor_by_Name:End-------------------------------------------------------------------


  //--------------------------------------------------------8:destroy_All_acceptor:Begin-------------------------------------------------------------------
  //Закрывает все ранее доабвленные Аццеторы.

  bool flush_flag = true;                    //true - значит при закрытии Аццептора, если на нем есть в момент закрытия Сокеты, на которых есть незавершенные операции отправки данных, дождатся полной отправки данных и только после этого закрыть и удалить Аццептор; false - значит при закрытии Аццептора, функция не будет дожидатся завершения Исходящих операций отправки данных и просто прервет их.

  //TCP_Server_.destroy_All_acceptor(flush_flag);
  //--------------------------------------------------------8:destroy_All_acceptor:End-------------------------------------------------------------------


  //--------------------------------------------------------9:start_acceptor:Begin-------------------------------------------------------------------
  //Запускает ранее добавленный Аццептор на прослушку Входящих соединений.

  //----------------------------------------------------------------------------------------------
  Acceptor_struct Acceptor_struct__ref_2 = Acceptor_struct__ref;     //Ранее доавбленный Аццептор.

  Function(TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, bool Connection_flag) user_func_Connect = (TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct? Socket_Struct__ref, bool Connection_flag)
  {
    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов для конкретного Аццептора у которого вызывается метод "start_acceptor" - при изменении статуса уствноки соединения для Сокета.
    //TCP_Server__class__ref - ссылка на сам обьект класса "TCP_Server__class", который вызовал данный колбек.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.
    //Socket_Struct__ref     - ссылка на структуру сокета.
    //Connection_flag        - логический флаг соединения на Сокете "Socket_Struct__ref".


    if(Connection_flag == true)
    {
      print('${Acceptor_struct__ref.Acceptor_Name} :Connect new Socket');
    }
    else
    {
      print('${Acceptor_struct__ref.Acceptor_Name} :Socket Disconect');
    }

  };

  Function(TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct Socket_Struct_ref, Uint8List Incoming_data) user_func_Read = (TCP_Server__class TCP_Server__class__ref, Acceptor_struct Acceptor_struct__ref, Socket_Struct Socket_Struct_ref, Uint8List Incoming_data)
  {
    //Данный колбек будет вызыватся каждый раз, как будут приходить Входящие данные на Сокет у Аццнптора которому передается данный колбек.
    //TCP_Server__class__ref - ссылка на сам обьект класса "TCP_Server__class", который вызовал данный колбек.
    //Acceptor_struct__ref   - ссылка на обьект Аццептора.
    //Socket_Struct__ref     - ссылка на структуру Сокета.
    //Incoming_data          - Буфер "Uint8List" с пришедшими Входящими данными доступными для чтения в данный момент. После завершения колбека ссылка на днные "Incoming_data" - становтся невалдиными, обращатся к ним уже Нельзя! Поэтому если нужно их сохранить - данные необхоимо ПЕРЕКОПИРОВАТЬ в свой буффер.


    print("${Acceptor_struct__ref.Acceptor_Name} : data_bytes_size: ${Incoming_data.length} : ${Incoming_data}");
    print('${Acceptor_struct__ref.Acceptor_Name} : data_bytes_size: ${Incoming_data.length} : ${utf8.decode(Incoming_data)}');   //Преобразуем данные из буффера в Dart`овский String(UTF-16), но при это нужно гарантированно знать, что в "data" находится валидная UTF-8 кодировка, иначе ошибка в рантайме.

  };
  //----------------------------------------------------------------------------------------------


  Acceptor_struct__ref.start_acceptor(user_func_Connect, user_func_Read);          //Если какой то Колбек не нужен - можно передать "null".
  //--------------------------------------------------------9:start_acceptor:End-------------------------------------------------------------------


  //--------------------------------------------------------10:destroy_acceptor:Begin-------------------------------------------------------------------
  //Уничтожает Аццептор: закрывает все Сокеты на нем, закрывает сам Аццептор и удаляет структуру Аццептора из списка Аццепторов.


  bool flush_flag_1 = true;                    //true - значит при закрытии Аццептора, если на нем есть в момент закрытия Сокеты, на которых есть незавершенные операции отправки данных, дождатся полной отправки данных и только после этого закрыть и удалить Аццептор; false - значит при закрытии Аццептора, функция не будет дожидатся завершения Исходящих операций отправки данных и просто прервет их.

  //Acceptor_struct__ref.destroy_acceptor(flush_flag_1);
  //--------------------------------------------------------10:destroy_acceptor:End-------------------------------------------------------------------


  //--------------------------------------------------------11:get__Socket_List_Size:Begin-------------------------------------------------------------------
  //Возвращает кол-во Сокетов на данном Аццепторе - и закрытых и открытых.

  int Socket_num = Acceptor_struct__ref.get__Socket_List_Size();

  print("Socket_num:${Socket_num}");
  //--------------------------------------------------------11:get__Socket_List_Size:End-------------------------------------------------------------------


  //--------------------------------------------------------12:close_Socket:Begin-------------------------------------------------------------------
  //Закрывает указанный Сокет у Аццептора в Синхронном режиме. То есть функция вернется только тогда, когда Сокет будет закрыт.

  //-----------------------------------------
  Socket_Struct Socket_Struct_ref;             //Созданный на Аццепторе Сокет. Созданный Сокет возвращется в колбеке установленным или при вызове "set__Shared_Callback_for_Connect" или при вызове "start_acceptor".

  bool flush_flag_2 = true;                    //true - значит при закрытии Аццептора, если на нем есть в момент закрытия Сокеты, на которых есть незавершенные операции отправки данных, дождатся полной отправки данных и только после этого закрыть и удалить Аццептор; false - значит при закрытии Аццептора, функция не будет дожидатся завершения Исходящих операций отправки данных и просто прервет их.

  bool erase_socket_flag = false;              //true - значит структура Сокета будет удалена из списка Сокетов Аццептора; false - значит структура Сокета не будет удалена из списка Сокетов Аццептора.
  //-----------------------------------------

  //await Acceptor_struct__ref.close_Socket(Socket_Struct_ref, flush_flag, erase_socket_flag)
  //--------------------------------------------------------12:close_Socket:End-------------------------------------------------------------------


  //--------------------------------------------------------13:close_AllSocket:Begin-------------------------------------------------------------------
  //Закрывает все Сокеты у Аццептора, которые есть на момент вызова данного метода в списке доабвленных сокетов в Синхронном режиме. То есть функция вернется только тогда, когда Сокет будет закрыт.

  //------------------------------------------------
  bool flush_flag_3 = true;                      //true - значит при закрытии Аццептора, если на нем есть в момент закрытия Сокеты, на которых есть незавершенные операции отправки данных, дождатся полной отправки данных и только после этого закрыть и удалить Аццептор; false - значит при закрытии Аццептора, функция не будет дожидатся завершения Исходящих операций отправки данных и просто прервет их.

  bool erase_socket_flag_3 = false;              //true - значит структура Сокета будет удалена из списка Сокетов Аццептора; false - значит структура Сокета не будет удалена из списка Сокетов Аццептора.
  //------------------------------------------------

  //Acceptor_struct__ref.close_AllSocket(flush_flag_3, erase_socket_flag_3);
  //--------------------------------------------------------13:close_AllSocket:End-------------------------------------------------------------------

  //--------------------------------------------------------14:destroy_Socket:Begin-------------------------------------------------------------------
  //Уничтожает Сокет у Аццептора, при уничтожении Не ждет отправки всех данных, которые еще не отправлены, которые есть во внутреннем буффере.
  //И удаляем сокет из списка доабвленных сокетов, поэтому обращатся к нему больше нельзя.
  //Функция синхронная, то есть функция не завершится, пока Сокет не будет уничтожен.

  //-----------------------------------------
  Socket_Struct Socket_Struct_ref_4;             //Созданный на Аццепторе Сокет. Созданный Сокет возвращется в колбеке установленным или при вызове "set__Shared_Callback_for_Connect" или при вызове "start_acceptor".

  bool erase_socket_flag_4 = false;              //true - значит структура Сокета будет удалена из списка Сокетов Аццептора; false - значит структура Сокета не будет удалена из списка Сокетов Аццептора.
  //-----------------------------------------

  //Acceptor_struct__ref.destroy_Socket(Socket_Struct_ref_4, erase_socket_flag_4);

  //--------------------------------------------------------14:destroy_Socket:End-------------------------------------------------------------------


  //--------------------------------------------------------15:destroy_AllSocket:Begin-------------------------------------------------------------------

  //Уничтожает Все Сокеты, при уничтожении Не ждет отправки всех данных, которые еще не отправлены, которые есть во внутреннем буффере.
  //И удаляем сокеты из списка доабвленных сокетов, поэтому обращатся к нем больше нельзя.
  //Функция синхронная, то есть функция не завершится, пока Все Сокеты не будет уничтожен.


  bool erase_socket_flag_5 = false;              //true - значит структура Сокета будет удалена из списка Сокетов Аццептора; false - значит структура Сокета не будет удалена из списка Сокетов Аццептора.

  //Acceptor_struct__ref.destroy_AllSocket(erase_socket_flag_5);
  //--------------------------------------------------------15:destroy_AllSocket:End-------------------------------------------------------------------


  //--------------------------------------------------------16:set__ReadParamFlag_for_Socket:Begin-------------------------------------------------------------------
  //Устанавливает для всех Сокетов Аццептора паарметр Чтения Входящих данных.

  //------------------------------------------------------
  read_flag read_flag_ = read_flag.Original_chunk;

  //Original_chunk     - Значит, что каждый Входящий буффер данных стразу будет отправлятся в Пользовательский колбек без каких либо дополнительных действий.
  //Accumulate_buffer  - Значит, что каждый Входящий буффер данных будет добовлятся в "_Read__AccumulateBuffer" буффер до указанного в "_Read__Accumulate_size" размера - при жостижении размера буффера >= "_Read__Accumulate_size" в колбек будет напарвлятся указатель на часть данных размером "_Read__Accumulate_size" и после колбека будет удалена.
  //Read_untill        - Значит, что каждый Входящий буффер данных будет добовлятся в "_Read__ReadUntill" до тех пор пока не будет найден заданный Пользователем "разделитель" после чего будет вызван Пользоватльеский колбек и после колбека данные до разделителя и сам разделитель будут удалены. То сть оповещение через установленные колбеки будет только тогда, когда во Входящих данных будет найден установленный разделитель с помощью "set__ReadUntill_Seperator_for_Socket". ТО ЕСТЬ: Пояснение: к примеру разделитель это символ "$", сам Входящий буффер содержит в моменте такие данные: 1234$56$789 - то есть в буффере присутствует ДВА разделителя и ТРИ разделенные подстроки, ТРЕТЬЮ подстроку "789" мы не трогаем и сообщаем о ней Пользователю через колбек, так как для нее еще не пришел свой разделитель. Мы его оставляет в буффере для следующего накопления данных и поиска разделителя. Для подстрок "1234" и "56" - будет вызвана два отдельных колбека.
  //------------------------------------------------------

  Acceptor_struct__ref.set__ReadParamFlag_for_Socket(read_flag_);
  //--------------------------------------------------------16:set__ReadParamFlag_for_Socket:End-------------------------------------------------------------------


  //--------------------------------------------------------17:set__ReadUntill_Seperator_for_Socket:Begin-------------------------------------------------------------------
  //Устанавливает разделитель для параметра чтения "ReadUntill".

  //-----------------------------------------------------------------
  Uint8List separator = Uint8List.fromList(utf8.encode(","));
  //-----------------------------------------------------------------


  Acceptor_struct__ref.set__ReadUntill_Seperator_for_Socket(separator);

  //--------------------------------------------------------17:set__ReadUntill_Seperator_for_Socket:End-------------------------------------------------------------------


  //--------------------------------------------------------18:set__AccumulateBuffer_Size_for_Socket:Begin-------------------------------------------------------------------
  //Устанавливает размер накопительного буффера для всех Сокетов у Аццептора для параметра чтения "AccumulateBuffer". По уомлчанию установлено значение 1024 байт.

  //-----------------------------------------------------------------
  int AccumulateBuffer_Size = 100;
  //-----------------------------------------------------------------

  Acceptor_struct__ref.set__AccumulateBuffer_Size_for_Socket(AccumulateBuffer_Size);
  //--------------------------------------------------------18:set__AccumulateBuffer_Size_for_Socket:End-------------------------------------------------------------------


  //--------------------------------------------------------19:send__Bytes_to_socket:Begin-------------------------------------------------------------------
  //Отправляет данные в Сокет у Аццептора для передачи по установленному соединению на удаленный IP.

  //-----------------------------------------------------
  Socket_Struct Socket_Struct_ref_1;                                  //Созданный на Аццепторе Сокет. Созданный Сокет возвращется в колбеке установленным или при вызове "set__Shared_Callback_for_Connect" или при вызове "start_acceptor".

  Uint8List Data_to_send = Uint8List.fromList(utf8.encode("GET / HTTP/1.1\r\nHost: google.com\r\n\r\n"));   //Сырой буффер данных Uint8 для отправки.     "Hello from Dart"

  bool copy_data_flag = true;    //Флаг копирования исходного Пользвотельского буффера "Data_to_send" во внутренний буффер класса. true - сделать копию буффера(с буффер "Data_to_send" можно делать все что угодно, после завершения вызова данного метода), false - неделать копию буффера(тогда буффер "Data_to_send" должен быть валидным до тех пор пока данные не отправятся)  Пояснение: Так как при передаче данных с помощью "add" - требуется, чтобы исходный буффер сохранялся и не изменялся на все время передачи, то, чтобы Пользователь не держал буффер сохранным можно сделать его копию внутри класса, который освободится сборщиком мусора, когда он уже будет ен нужен.
  //-----------------------------------------------------

  //Acceptor_struct__ref.send__Bytes_to_socket(Socket_Struct_ref_1, Data_to_send, copy_data_flag);
  //--------------------------------------------------------19:send__Bytes_to_socket:End-------------------------------------------------------------------




  //--------------------------------------------------------TCP_Server__class:End-----------------------------------------------------------------------





}
